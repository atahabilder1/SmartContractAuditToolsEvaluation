// SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol";
import "./ICreatorRoyaltyMinter.sol";

contract EnterNFT is ICreatorRoyaltyMinter, Initializable, UUPSUpgradeable, ContextUpgradeable, AccessControlEnumerableUpgradeable, ERC721URIStorageUpgradeable, ERC721EnumerableUpgradeable, ERC721BurnableUpgradeable, ERC721PausableUpgradeable, ReentrancyGuardUpgradeable {
  struct Royalty {
    address recipient;    // recipient address
    uint16 rate;          // percentage rate 0-10,000 (map to 0%-100%), measured in basis points (1/100 of a percent). 1 is 0.01%, 10,000 is 100%.
  }

  using CountersUpgradeable for CountersUpgradeable.Counter;

  bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
  bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
  bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR_ROLE");
  uint16  public constant INVERSE_BASIS_POINT = 10000;

  CountersUpgradeable.Counter private _tokenIdTracker;      // tokenId counter
  string private _baseTokenURI;                             // baseTokenURI
  mapping (uint256 => Royalty) private _creatorRoyalties;   // tokenId to creator royalty mapping
  bool public isTokensBurningAllowed;                       // whether allow to burn tokens

  function initialize(string memory name, string memory symbol, string memory baseTokenURI) public virtual initializer {
    __EnterNFT_init(name, symbol, baseTokenURI);
  }

  function _authorizeUpgrade(address) internal override view {
    require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "EnterNFT: must have admin role to upgrade");
  }

  /**
   * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the
   * account that deploys the contract.
   *
   * Token URIs will be autogenerated based on `baseURI` and their token IDs.
   * See {ERC721-tokenURI}.
   */
  function __EnterNFT_init(string memory name, string memory symbol, string memory baseTokenURI) internal initializer {
    __ERC1967Upgrade_init_unchained();
    __UUPSUpgradeable_init_unchained();
    __Context_init_unchained();
    __ERC165_init_unchained();
    __AccessControl_init_unchained();
    __AccessControlEnumerable_init_unchained();
    __ERC721_init_unchained(name, symbol);
    __ERC721URIStorage_init_unchained();
    __ERC721Enumerable_init_unchained();
    __ERC721Burnable_init_unchained();
    __Pausable_init_unchained();
    __ERC721Pausable_init_unchained();
    __ReentrancyGuard_init_unchained();
    __EnterNFT_init_unchained(baseTokenURI);
  }

  function __EnterNFT_init_unchained(string memory baseTokenURI) internal initializer {
    _baseTokenURI = baseTokenURI;
    isTokensBurningAllowed = false;

    _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
    _setupRole(MINTER_ROLE, _msgSender());
    _setupRole(PAUSER_ROLE, _msgSender());
    _setupRole(OPERATOR_ROLE, _msgSender());
  }

  function _baseURI() internal view virtual override returns (string memory) {
    return _baseTokenURI;
  }

  /**
   * @dev Creates a new token for `to`. Its token ID will be automatically
   * assigned (and available on the emitted {IERC721-Transfer} event), and the token
   * URI autogenerated based on the base URI passed at construction.
   *
   * See {ERC721-_mint}.
   *
   * @param _to - creator address
   * @param _royaltyRate - royalty percentage rate 0-10,000 (map to 0%-100%). Measures in basis points (1/100 of a percent), so 1 is 0.01%, 10,000 is 100%.
   *
   * Requirements:
   *
   * - the caller must have the `MINTER_ROLE`.
   */
  function mint(address _to, uint16 _royaltyRate, string memory _tokenURI) public override returns (uint256 tokenId) {
    require(hasRole(MINTER_ROLE, _msgSender()), "EnterNFT: must have minter role to mint");
    require(_royaltyRate >= 0 && _royaltyRate < 10000, "EnterNFT: royalty rate must be between 0 and 10000");

    _tokenIdTracker.increment();
    uint256 newTokenId = _tokenIdTracker.current();

    _mint(_to, newTokenId);
    _creatorRoyalties[newTokenId] = Royalty({ recipient: _to, rate: _royaltyRate });
    _setTokenURI(newTokenId, _tokenURI);
    
    return newTokenId;
  }

  /**
   * @dev Pauses all token transfers.
   *
   * See {ERC721Pausable} and {Pausable-_pause}.
   *
   * Requirements:
   *
   * - the caller must have the `PAUSER_ROLE`.
   */
  function pause() public virtual {
    require(hasRole(PAUSER_ROLE, _msgSender()), "EnterNFT: must have pauser role to pause");
    _pause();
  }

  /**
   * @dev Unpauses all token transfers.
   *
   * See {ERC721Pausable} and {Pausable-_unpause}.
   *
   * Requirements:
   *
   * - the caller must have the `PAUSER_ROLE`.
   */
  function unpause() public virtual {
    require(hasRole(PAUSER_ROLE, _msgSender()), "EnterNFT: must have pauser role to unpause");
    _unpause();
  }

  function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721Upgradeable, ERC721EnumerableUpgradeable, ERC721PausableUpgradeable) {
    require(from == address(0) || to == address(0) || hasRole(OPERATOR_ROLE, _msgSender()), "EnterNFT: must be either mint or burn operations or sender must have operator role to transfer token");
    super._beforeTokenTransfer(from, to, tokenId);
  }

  /**
   * @dev See {IERC165-supportsInterface}.
   */
  function supportsInterface(bytes4 interfaceId) public view virtual override(AccessControlEnumerableUpgradeable, ERC721Upgradeable, ERC721EnumerableUpgradeable) returns (bool) {
    return interfaceId == type(ICreatorRoyaltyMinter).interfaceId || super.supportsInterface(interfaceId);
  }

  /**
   * @dev See {IERC721Metadata-tokenURI}.
   */
  function tokenURI(uint256 tokenId) public view virtual override(ERC721Upgradeable, ERC721URIStorageUpgradeable) returns (string memory) {
    return super.tokenURI(tokenId);
  }

  /**
   * @dev Destroys `tokenId`.
   * The approval is cleared when the token is burned.
   *
   * Requirements:
   *
   * - `tokenId` must exist.
   *
   * Emits a {Transfer} event.
   */
  function _burn(uint256 tokenId) internal virtual override(ERC721Upgradeable, ERC721URIStorageUpgradeable) {
    require(isTokensBurningAllowed, "EnterNFT: tokens are not allowed to be burned.");
    super._burn(tokenId);
  }

  function allowBurning(bool allow) public {
    require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "EnterNFT: must have admin role to allow burning.");
    isTokensBurningAllowed = allow;
  }

  /**
   * @dev Returns the creator of the `_tokenId` token.
   *
   * Requirements:
   *
   * - `_tokenId` must exist.
   */
  function creatorOf(uint256 _tokenId) public view override returns (address) {
    Royalty storage royalty = _creatorRoyalties[_tokenId];
    require(royalty.recipient != address(0), "EnterNFT: creator query for nonexistent token");
    return royalty.recipient;
  }

  /**
   * @dev Called with the sale price to determine how much royalty is owed and to whom.
   *
   * @param _tokenId - the NFT asset queried for royalty information
   * @param _value - the sale price of the NFT asset specified by _tokenId
   *
   * @return _receiver - address of who should be sent the royalty payment
   * @return _royaltyAmount - the royalty payment amount for _value sale price
   *
   * Requirements:
   *
   * - `_tokenId` must exist.
   */
  function royaltyInfo(uint256 _tokenId, uint256 _value) external view override returns (address _receiver, uint256 _royaltyAmount) {
    Royalty storage royalty = _creatorRoyalties[_tokenId];
    require(royalty.recipient != address(0), "EnterNFT: royalty query for nonexistent token");
    uint256 amount = _value * royalty.rate / INVERSE_BASIS_POINT;
    return (royalty.recipient, amount);
  }

  uint256[46] private __gap;
}
