pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../interfaces/IDepositExecute.sol";
import "./HandlerHelpers.sol";
import "../ERC20Safe.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "../uniswapv2/interfaces/IUniswapV2Router02.sol";
import "../interfaces/IWNATIVE.sol";
import "../utils/TransferHelper.sol";

/**
    @title Modified ERC20 handler to support native token swap
    @author ChainSafe Systems and DCTDAO
    @notice This contract is intended to be used with the Bridge contract.
 */

 /*
 IMPORTANT!: This contract is the same as ERC20 handler, but DepositRecord structure is the same as in
 GenericHandler. The reason is that ERC20 handler DepositRecord does not support bytes transfer, which is necessery.

 For relays this contract should be set as GenericHandler, but interaction with the contract should be the same as for ERC20Handler.
 */
contract ERC20GenericNativeSwap is IDepositExecute, HandlerHelpers, ERC20Safe, Ownable {
    struct DepositRecord {
        uint8   _destinationChainID;
        address _depositer;
        bytes32 _resourceID;
        bytes   _metaData;
    }

    //Address of DEX router
    address public router;
    //Address of WNATIVE token for the given chain
    address public _WNATIVE;
    //events, if the swap fails for unkown reason
    event swapFailure(address indexed recipient, string stringErr, bytes bytesErr);
    event swapSuccessful(address indexed recipient, uint[] amounts);


    // destId => depositNonce => Deposit Record
    mapping (uint8 => mapping(uint64 => DepositRecord)) public _depositRecords;

    receive() external payable {
        assert(msg.sender == _WNATIVE); // only accept NATIVE via fallback from the WNATIVE contract
    }

    /**
        @param bridgeAddress Contract address of previously deployed Bridge.
        @param WNATIVE Contract address of Wrapped native token (e. g. WETH on ETH)
        @param initialResourceIDs Resource IDs are used to identify a specific contract address.
        These are the Resource IDs this contract will initially support.
        @param initialContractAddresses These are the addresses the {initialResourceIDs} will point to, and are the contracts that will be
        called to perform various deposit calls.
        @param burnableContractAddresses These addresses will be set as burnable and when {deposit} is called, the deposited token will be burned.
        When {executeProposal} is called, new tokens will be minted.
        @dev {initialResourceIDs} and {initialContractAddresses} must have the same length (one resourceID for every address).
        Also, these arrays must be ordered in the way that {initialResourceIDs}[0] is the intended resourceID for {initialContractAddresses}[0].
     */
    constructor(
        address          bridgeAddress,
	    address          WNATIVE,
        bytes32[] memory initialResourceIDs,
        address[] memory initialContractAddresses,
        address[] memory burnableContractAddresses
    ) public {
        require(initialResourceIDs.length == initialContractAddresses.length,
            "initialResourceIDs and initialContractAddresses len mismatch");

        _bridgeAddress = bridgeAddress;
	    _WNATIVE = WNATIVE;
        for (uint256 i = 0; i < initialResourceIDs.length; i++) {
            _setResource(initialResourceIDs[i], initialContractAddresses[i]);
        }

        for (uint256 i = 0; i < burnableContractAddresses.length; i++) {
            _setBurnable(burnableContractAddresses[i]);
        }
    }

     /**
        @param depositNonce This ID will have been generated by the Bridge contract.
        @param destId ID of chain deposit will be bridged to.
        @return DepositRecord which consists of:
        - _destinationChainID ChainID deposited tokens are intended to end up on.
        - _resourceID ResourceID used when {deposit} was executed.
        - _depositer Address that initially called {deposit} in the Bridge contract.
        - _metaData Data to be passed to method executed in corresponding {resourceID} contract.
    */
    function getDepositRecord(uint64 depositNonce, uint8 destId) external view returns (DepositRecord memory) {
        return _depositRecords[destId][depositNonce];
    }

    /**
        @param resourceID This is ID, which idetifies the token between mutiple chain (links)
        @param destinationChainID ID of chain deposit will be bridged to.
        @param depositNonce Nonce
        @param depositer address of caller of the deposit fucntion
    */
    function deposit(
        bytes32 resourceID,
        uint8   destinationChainID,
        uint64  depositNonce,
        address depositer,
        bytes   calldata data
    ) external override onlyBridge {
	bytes  memory destinationRecipientAddress;
        uint256        amount;
        uint256        swapPer;
        uint256        lenRecipientAddress;

        (amount, swapPer, lenRecipientAddress) = abi.decode(data, (uint256, uint256, uint256));

        //verifies percentages
        require(swapPer <= 10000, "Invalid percentage");

        address tokenAddress = _resourceIDToTokenContractAddress[resourceID];
        require(_contractWhitelist[tokenAddress], "provided tokenAddress is not whitelisted");

        if (_burnList[tokenAddress]) {
            burnERC20(tokenAddress, depositer, amount);
        } else {
            lockERC20(tokenAddress, depositer, address(this), amount);
        }

        _depositRecords[destinationChainID][depositNonce] = DepositRecord(
            destinationChainID,
            depositer,
            resourceID,
            data
        );
    }

    /**
        @param resourceID This is ID, which idetifies the token between mutiple chain (links)
        @param data  which consists of:
        - lenFromServerGeneric Length of data added by relayer
        - amount Amount of tokens to be minted/unlocked
        - swapPer Percentage of the tokens to be swaped to native token
        - lenRecipientAddress Length of recipient address, usually 20
        - recipientAddress recipeint Address
    */
    function executeProposal(bytes32 resourceID, bytes calldata data) external override onlyBridge {
        uint256       lenFromServerGeneric; //Not used, but needed for decoding
        uint256       amount;
        uint256       swapPer;
        uint256       lenRecipientAddress;
        bytes  memory destinationRecipientAddress;
        uint256 swapTokens;



        (lenFromServerGeneric, amount, swapPer, lenRecipientAddress) = abi.decode(data, (uint256, uint256, uint256, uint256));
        //swapPer should be already verified by deposit function
        destinationRecipientAddress = bytes(data[32*4:32*4 + lenRecipientAddress]);

        bytes20 recipientAddress;
        address tokenAddress = _resourceIDToTokenContractAddress[resourceID];

        assembly {
            recipientAddress := mload(add(destinationRecipientAddress, 0x20))
        }
        require(_contractWhitelist[tokenAddress], "provided tokenAddress is not whitelisted");
        
        swapTokens = (amount/10000)*swapPer;
        amount = amount - swapTokens;
        
        if(swapTokens > 0){
    	    releaseTokens(tokenAddress, address(this), swapTokens); //release to us the tokens for swap
            if(tokenAddress == _WNATIVE){
		//We just unwrap that amount of percentage
		IWNATIVE(_WNATIVE).withdraw(swapTokens);
		//Now we transfer the tokens
		TransferHelper.safeTransferNATIVE(address(recipientAddress), swapTokens);
	     } else {
		if(router != address(0)){
    	             //the token is ERC20, so we will use DEX to swap Percentage to the native token
    	             IERC20(tokenAddress).approve(router, swapTokens);
    	             IUniswapV2Router02 r = IUniswapV2Router02(router);
    	             address[] memory path = new address[](2);
        	     path[0] = tokenAddress;
                     path[1] = _WNATIVE;
        		     
        	     //swap the tokens
        	     try r.swapExactTokensForNATIVE(swapTokens,
                    	0, //we do not do any check here
                    	path,
                    	address(recipientAddress),
                    	now + 30* 1 minutes)
                     returns (uint[] memory amounts) {
                    	emit swapSuccessful(address(recipientAddress), amounts);
                     } catch Error(string memory _err) {
                    	IERC20(tokenAddress).transfer(address(recipientAddress), swapTokens);
                    	emit swapFailure(address(recipientAddress), _err, bytes(""));
                     } catch (bytes memory _err) {
                    	IERC20(tokenAddress).transfer(address(recipientAddress), swapTokens);
                    	emit swapFailure(address(recipientAddress), "", _err);
                    }
	       } else {
		//We have to send back the swap amount, because router was not set
                IERC20(tokenAddress).transfer(address(recipientAddress), swapTokens);
		}
	     }
            
        }
        if(amount > 0){
            releaseTokens(tokenAddress, address(recipientAddress), amount); // here we release the rest of the tokens
        }
    }

    /**
        @notice Encapsuled minting of releasing token
        @param tokenAddr Address of token contract to release.
        @param recipient Address to release tokens to.
        @param amount The amount of ERC20 tokens to release.
     */
    function releaseTokens(address tokenAddr, address recipient,uint256 amount) internal {
         if (_burnList[tokenAddr]) {
            mintERC20(tokenAddr, recipient, amount);
        } else {
            releaseERC20(tokenAddr, recipient, amount);
        }

    }

    /**
        @notice Used to manually release ERC20 tokens from ERC20Safe.
        @param tokenAddress Address of token contract to release.
        @param recipient Address to release tokens to.
        @param amount The amount of ERC20 tokens to release.
     */
    function withdraw(address tokenAddress, address recipient, uint amount) external override onlyBridge {
        releaseERC20(tokenAddress, recipient, amount);
    }

    /**
        @notice Set router DEX addr
        @param _router Set Router address
     */
    function setRouter(address _router) external onlyOwner {
        router = _router;
    }

}
